function main()
local str = "qwe,rty , uio, rty, uio, rty, uio, rty,rty , uio, rty, uio, rt"
function string:split_a(sStr, sDiv, Mode)
	local tRet, sPattern = {}, '[%w%_]+' --/ шаблон для разделения строки на слова
	if sDiv and type(sDiv) == 'string' then --/ если divider задан:
		sPattern = '%s*([^'..sDiv..']+)%s*' --/ разделяем по нему с фильтрацией примыкающих пробелов
	end
	if Mode == nil then --/ обычный массив
		for sValue in sStr:gmatch(sPattern) do
			table.insert(tRet, sValue)
		end
	elseif Mode == true then --/ таблица '[значение]=true'
		for sValue in sStr:gmatch(sPattern) do
			tRet[sValue] = true
		end
	elseif Mode == false then --/ таблица '[idx] = число или стринг'
		local iIdx = 1
		for sValue in sStr:gmatch(sPattern) do
			--table.insert(tRet, tonumber(sValue) or sValue)
			tRet[iIdx] = tonumber(sValue) or sValue
			iIdx = iIdx +1
		end
	elseif type(Mode) == 'string' then --/ TODO: доделать или выкинуть!
		local sKey
		for sValue in sStr:gmatch(sPattern) do
			if tRet[sValue] then
				tRet[sValue] = tRet[sValue] +1
			elseif sKey then
				if type(sValue) == 'string' and sValue == sKey then
					tRet[sKey] = 2
				elseif tonumber(sValue) then
					tRet[sKey] = tonumber(sValue) -1
					sKey = nil
				else --/#?#
					to_log(string.exformat("fSplitStrToTbl:Value(%s)=[%s]~?,Key=[%s],Str=[%s]:<%s>", type(sStr), sValue, sKey, sStr, "Warning!"))
				end
			elseif type(sValue) == 'string' then
				tRet[sValue] = 1
				sKey = sValue --/ запоминаем ключ
			else --/#?#
				to_log(string.exformat("fSplitStrToTbl:Value(%s)=[%s]~?,Str=[%s]:<%s>", type(sStr), sValue, sStr, "Warning!"))
			end
		end
	end
	--table.print(tRet,sModule..":SplitStrToTbl") --/#~#
	return tRet --/>
end

local match = string.match
function string:trim1()
	return match(self,'^()%s*$') and '' or match(self,'^%s*(.*%S)')
end
function string:split_s(sep)
	local sep, t = sep or ",", {}
	local pattern = string.format("([^%s]+)", sep)
	self:gsub(pattern, function(c) t[#t + 1] = c:trim() end)
	return t
end
function string:split_a(sDiv)
	local tRet, sPattern = {}, '[%w%_]+' --/ шаблон для разделения строки на слова
	if sDiv and type(sDiv) == 'string' then --/ если divider задан:
		sPattern = '%s*([^'..sDiv..']+)%s*' --/ разделяем по нему с фильтрацией примыкающих пробелов
	end
		for sValue in self:gmatch(sPattern) do
			table.insert(tRet, sValue)
		end
		return tRet
end
local function printt(t)
for k, v in pairs(t) do
	-- log("["..k.."]="..tostring(v))
end
end
local tm = 0
local max=1000
local pt = profile_timer()
for i = 1,max do
pt = profile_timer()
pt:start()
local t = str:split()
-- printt(t)
pt:stop()
tm=tm+pt:time()
end
log("time1="..tm/max)
local tm = 0
local pt = profile_timer()
for i = 1,max do
pt = profile_timer()
pt:start()
local t = str:split_s()
-- printt(t)
pt:stop()
tm=tm+pt:time()
end
log("time_s="..tm/max)
local tm = 0
local pt = profile_timer()
for i = 1,max do
pt = profile_timer()
pt:start()
local t = str:split_a(",")
-- printt(t)
pt:stop()
tm=tm+pt:time()
end
log("time_a="..tm/max)

safe_test = nil
end
main()